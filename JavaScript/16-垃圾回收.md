# 垃圾回收

## 内存生命周期

1. 分配内存
2. 使用分配到的内存读写
3. 释放内存

所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。

核心问题：我们知道当内存不再需要时释放，问题是哪些被分配的内存确实已经不再需要了？下面两种算法就是为了解决这个问题。

## 垃圾回收

### 引用计数

> 最初级的垃圾收集算法。把“对象是否不再需要”简化定义为“对象没有其他对象引用到它”。

缺点：无法解决循环引用

IE6，7使用引用计数对DOM对象进行垃圾回收。

### 标记清除

> 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根的对象（如全局对象）。垃圾回收期将定期从根开始，找所有从根开始引用的对象，然后找到这个对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得对象。

从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记清除算法的改进，并没有改进标记清除算法本身和它对“对象是否不再需要”的简化定义。

优点：不存在循环引用问题。

限制：无法从根对象查询到的对象都将被清除。

## 案例——V8引擎的垃圾回收机制

- 分代回收

V8引擎将内存分为两个部分，**新生代和老年代**，这两个部分里面的大小空间和生命周期是不一样的。

1. 新生代中的空间较小，生命周期较短。在新生代空间中，其中空间主要分为两个部分：使用和空闲。当其中一个部分的内存被填满之后，新生代算法就会启动，将这部分里面存活的对象转移到另外一个部分，并且将失活的对象销毁。如此一个来回就是一个新生代的算法过程，并且会给每一个进行过一个来回的对象打上标记。
2. 老年代的空间较大，生命周期也很长。对象进入老年代算法种只有两个情况：在新生代经历过一次轮回并且被打上标记，第二种就是对象的大小占用了新生代的**25%**的对象。老年阶段会遍历所有对象，然后标记存活的对象，然后销毁所有失活的对象。
3. 清除对象的内存碎片过多时会启动**压缩算法**，将碎片压缩，然后移动存活的对象，再释放掉内存，释放完成后再将对象重新移动进去。

---

参考：

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

黑马教程