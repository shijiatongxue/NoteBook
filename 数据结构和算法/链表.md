# 链表

## 在O(1)的时间删除链表节点

题目描述：给定链表头指针和一个节点指针，在O(1)时间删除该节点。

分析：将该节点的值改为下一个节点的值，然后将它的指针指向下一个节点的下一个节点。但是这个方法无法处理尾部节点。

## 单链表的转置

题目描述：输入一个单向链表，输出反转后的链表。

分析：使用3个指针，pre，head，next，分别指向head的前一个节点，当前节点，和下一个head节点。

## 求链表的倒数第K个节点

题目描述：输入一个单向链表，输入该链表的倒数第K个节点。

分析：设置两个指针，首先都指向head，然后一个向前走K步，这时同时移动两个指针，直到先走的到达链表末尾（空指针），慢的指向的就是倒数第K个节点。

## 单链表是否存在环

题目描述：输入一个单向链表，判断链表是否有环？

分析：设置快慢指针，判断慢指针到达末尾时，两个指针会不会相遇。

## 两个链表是否相交

题目描述：给出两个单向链接的头指针，判断链表是否相交。

概念：由于链表next使用的是指针，如果存在一个相交节点，则后面的都是相交的，直到链表结束。

分析：

- 暴力解法：从头遍历第一个链表，每前进一步，对第二个链表进行从头到尾的比较。复杂度为O(N*M)
- 哈希：对第一个链表的每一项地址进行哈希，然后对第二个链表进行遍历，查看是否有相同地址值的节点。复杂度为O(N+M)，空间复杂度为O(N)
- 环：把第二个链表拼接到第一个链表，从第二个链表头开始遍历，查看是否有环。若有环，说明相交。这个方法时间复杂度为O(M)，空间是常数。
- 优化：针对链表相交的特点，可以对末尾节点进行判断，若相等则相交。时间复杂度为O(M+N)，空间复杂度为O(1)，而且没有改变链表。

## 两链表相交的第一个公共节点

题目描述：如果两个无环单链表相交，怎么求出它们相交的第一个节点？

分析：先对齐，然后同时移动指针，直到相等。

## 有环链表如何判断相交

分析：有环链表相交，则两个链表都要有环。相交情况有3种，分别是在非环节点相遇、在环上相同节点和不同节点相遇。只需要判断是否共用一个环就可以了。

