# 关于this
为什么要使用this？因为this可以隐式地传递上下文。一般来说，谁调用一个函数，this就指向谁。
## 误解
- this指向函数本身
- this指向函数的作用域

## this到底是什么？
this是在运行时绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

由于函数在对象内部是一个单独的值，它保存在对象的[[value]]属性内，可以单独被访问。this用来指代函数的当前运行环境，没有this，我们就不知道函数内的变量到底是属于创建它的对象还是调用它的对象。

# this全面解析
## 调用位置
调用位置指的是当前正在执行函数的前一个调用。
## 绑定规则
- 默认绑定：this默认指向全局对象
- 隐式绑定：函数作为对象的方法调用时，this指向该对象
- 显示绑定：call()和apply()方法
- new绑定

使用new来调用函数，会自动发生下面的操作：

1. 创建一个全新的对象；
2. 将[[原型]]指向构造函数的prototype所指对象；
3. 将函数调用的this指向这个对象；
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 

## 优先级
new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

## 箭头函数
箭头函数不使用this的四种标准，而是根据外层（函数或全局）作用域来决定this。
```javascript
function foo(){
    return (a)=>{
        console.log(a);
    }
}
obj1 = {a = 2};
obj2 = {a = 3};
var bar = foo.call(obj1); 
bar.call(obj2); // => 2，不是3！
```
由于foo()的this绑定到obj1，bar的this也会绑定到obj1，箭头函数的绑定无法修改。（new也不行！）
## 关于this的使用风格
1. 只是用词法作用域并完全抛弃错误this风格的代码；
2. 完全采用this风格，在必要时使用bind()，尽量避免使用self=this和箭头函数。

# 对象
## 复制对象
- 浅复制
  - Object.assign()，**ES6**
- 深复制
  - var newObj = JSON.parse(JSON.stringify(someObj));
