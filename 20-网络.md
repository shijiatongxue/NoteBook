# 1 浏览器生成消息

- 生成HTTP请求消息
  - 浏览器如何解析网址
  - 请求消息长什么样？
- 向DNS服务器查询Web服务器的IP地址
  - 浏览器查询服务器的IP
- DNS服务器
  - DNS服务器之间的协作
- 委托协议栈发送消息
  - 委托操作系统发送消息

## 1.1 生成HTTP请求消息

### URL
包含协议类型、域名和文件路径等。

### 浏览器如何要解析URL?
根据URL得到协议类型、域名、端口号、路径名等。

### 省略文件名的情况
- https://www.github.com/dir/

一般我们在访问网站的时候不会输入文件名，这时浏览器会根据服务器事先配置好的默认访问文件名，大多数情况下是index.html或default.htm之类的。

- https://www.github.com/
  
有时还会出现访问根目录，情况与上面类似。

- https://www.github.com

当把根目录都省略时，就代表访问根目录下事先设置的默认文件。

- https://www.github.com/what

对于这种末尾没有'/'，一般不推荐使用。服务器会查询有没有这个文件，如果没有这个文件，则把它当作文件夹名处理。

### HTTP的基本思路
解析完URL，浏览器会使用HTTP协议来访问Web服务器。

HTTP请求包括两部分，“对什么”和“进行怎样操作”。

“对什么”：要访问的URI。

“进行什么操作”：

- **GET**：获取URI指定的信息。
- **POST**：从客户端向服务器发送数据。一般是表单。
- HEAD：和GET基本相同，区别在于只返回请求头。
- PUT：替换URI指定的服务器上的文件。或新建文件。
- DELETE：删除文件。
- TRACE：将服务器收到的请求行和头部直接返回给客户端。用于在使用代理的环境中检查改写请求的情况。
- CONNECT：使用代理传输加密消息时使用的方法。
- OPTIONS：用于通知或查询通信选项。

收到请求消息后，Web服务器会对其中的内容进行解析，通过URI和方法来判断“对什么”“进行怎样的操作”，并根据这些要求完成自己的工作，然后将结果放在相应消息中。

响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP的整个工作就完成了。

### 生成HTTP请求消息
首先，请求消息的第一行称为请求行。

**GET /dir/index.html HTTP/1.1**

第二行开始为消息头。

通用头：适用于请求和响应消息的头字段。
- Date
- Pragma：表示数据是否允许缓存
- Cache-Control：控制缓存的相关信息
- Connection：是否继续保持通信
- Transfer-Enconding
- Via

请求头：用于表示请求消息的附加信息的头字段
- Authorization：身份认证数据
- From：请求发送者的邮件地址
- Host：接收请求的服务器IP和端口号
- Referer
- User-Agent
- Accept-Charset
- Accept-Encoding
- Accept-Language
- If-Match
- If-None-Match
- If-Modified-Since：用于判断客户端缓存数据是否过期
- If-Unmodified-Since：在指定日期之后数据未更新时执行请求
- Range：当需要只获取部分数据而不是全部数据时，可通过这个字段指定要获取的数据范围

响应头：用于表示响应消息的附加信息的头字段
- Location：当前请求URI的据对路径
- Server：服务器程序的名称和版本号等相关信息。
- Accept-Ranges：当希望仅请求部分数据时，服务器会告知客户端是否支持这一功能。
- WWW-Authenticate

实体头：用于表示实体（消息体）的附加信息的头字段
- Allow：表示指定的URI支持的方法
- Content-Type：表示消息体的数据类型，以MIME规格定义的数据类型表示
- Content-Length
- Content-Encoding
- Content-Language：表示消息体的语言。
- Content-Location：表示消息体在服务器上的URI。
- Expires：表示消息体的有效期
- Last-Modified：数据的最后更新日期
- Content-Range：当仅请求部分数据时，表示消息体包含的数据范围
- Etag：在更新操作时，有时候需要基于上一次请求的响应数据来发送一下次请求，在这种情况下，这个字段可以用来提供上次响应与下次请求之间的关联信息。

当用POST方法时，需要将表单中填写的信息写在消息体中。

### 发送请求后会收到响应
响应消息与请求消息的差别只在第一行上。

在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。

状态码概要：

- 1xx：告知请求处理的进度和情况
- 2xx：成功
- 3xx：表示需要进一步操作
- 4xx：客户端错误
- 5xx：服务器错误

返回响应消息后，浏览器会将数据提取出来并显示在屏幕上。当网页包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。浏览器遇到图片相关标签时，会在屏幕上留出用来显示图片的空间，然后再次访问Web服务器，按照标签中指定的文件名向Web服务器请求获取相应的图片并显示在预留的空间中。

由于每条消息中只能写一个URI，所以每次只能获取一个文件，如果要获取多个文件，必须对每个文件单独发送一条请求。比如一个网页中包含3张图片，那么获取网页加上获取图片，一共需要向Web服务器发送4条请求。

## 1.2 向DNS服务器查询Web服务器IP地址
### IP地址
生成HTTP消息之后，接下来我们需要委托操作系统将信息发送给Web服务器。

尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能。

在此之前，我们需要查询网址中服务器域名对象的IP地址。

主机号部分的比特全部为0或者全部为1时代表两种特殊的含义。

- 主机号部分全部为0：代表整个子网
- 主机号部分全部为1：代表向子网上的所有设备发送包

### 域名和IP地址并用的理由
域名最短也要几十个字节，最长甚至可以达到255字节。

路由器的速度是有极限的，而互联网内部流动的数据量已然让路由器疲于应付了，因此我们不应该再采用效率更低的设计。

### Socket库提供查询IP地址的功能
向DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应。换句话说，对于DNS服务器，我们的计算机上一定有相应的DNS客户端，而相当于DNS客户端的部分称为DNS解析器，或者简称解析器。

解析器实际上是一段程序，它包含在操作系统的Socket库中。

Socket库中包含很多用于发送和接收数据的程序组件。

### 通过解析器向DNS服务器发送查询
```c
<应用程序名>(<参数>)
{
    ...
    <内存地址> = gethostbyname("www.github.com");
    ...
    <发送HTTP消息>
    ...
}
```
调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会相应消息。响应消息中包含查询到的IP，解析器会取出IP，并写入浏览器指定的内存地址中。接下来，浏览器再向Web服务器发送消息时，只要从内存地址取出IP，并将它与HTTP请求消息一起交给操作系统就可以了。

### 解析器内部原理
解析器收到一个域名后，会调用系统内部的协议栈，生成UDP包，然后向DNS服务器发送消息，接收到消息后，把结果返回浏览器。

当DNS服务器收到查询消息后，它会根据消息中的查询内容进行查询。如果要访问的Web服务器已经在DNS服务器上注册，那么这条记录就能够被找到，然后其IP会被写入响应消息并返回给客户端。

## 全世界DNS服务器的协作
### DNS服务器
来自客户端的查询消息：

- 域名
- Class

网络的类型，现在基本都是互联网了。用IN表示。
- 记录

表示域名对应何种类型的记录。A代表IP地址，MX代表邮件服务器。

域名|Class|记录类型|响应数据
-|-|-|-
www.github.com|IN|A|192.0.0.1
github.com|IN|MX|10 mail.github.com
mail.github.com|IN|A|192.0.0.2

当请求类型为A时，直接返回IP；当请求类型为MX时，会在消息保存邮件服务器域名和优先级，然后还有IP。

记录类型除了A和MX两种外，还有：

- PRT：根据IP反查域名
- CNAME：域名别名
- NS：查询DNS服务器IP
- SOA：查询域名属性信息

### 域名的层次结构
根据句点进行划分，越靠右等级越高。

### 寻找相应的DNS服务器并获取IP地址
如何找到我们要访问的Web服务器的信息归哪一台DNS服务器管。

根域名用.表示，在顶级域名后面，如www.github.com.，不过根域名一般被省略不写。根域名保存着顶级域名服务器的信息。由于上级DNS雾浮起保存着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下找到任意一个域的DNS服务器。

除此之外，还要将根域名DNS服务器信息保存在互联网所有DNS服务器中。

因此，客户端只要能找到任意一台DNS服务器，就可以通过它找到根域名DNS服务器，然后再一路找到位于下层某台目标DNS服务器。

分配给根域名DNS服务的IP地址在全世界仅有13个，这些地址几乎不发生变化。只要配置了DNS服务器程序，这些信息就被自动配置好了。

目标DNS服务器的查找过程：

假设我们要找www.github.com这台服务器的相关信息。

- 客户端A首先找到最近的DNS服务器B，也就是客户端配置的DNS服务器地址；
- B首先问根域名服务器，根域说没有，返回com域的DNS服务器地址；
- B询问com域，com域说没有，返回github.com的DNS服务器地址；
- 最后，B询问github.com域，返回www.github.com的Web服务器地址；
- B返回给客户端目标IP。

### 通过缓存加快DNS服务器的响应

DNS服务器有一个缓存功能，可以记住之前查询过的域名。下一次查询就可以快速对查询结果做出响应。

## 1.4 委托协议栈发送消息
### 数据收发操作概览
发送数据也需要调用系统Socket库中的程序组件。

收发数据的操作分为若干个阶段：

1. 创建套接字
2. 将管道连接到服务器端的套接字上
3. 收发数据
4. 断开管道并删除套接字

描述符：应用程序用来识别套接字的机制。

IP和端口号：客户端和服务器之间用来识别对方套接字的机制。

## 总结
在浏览器和Web服务器收发消息过程，实际负责收发消息的是协议栈、网卡驱动和网卡。下一章将对这部分进行探索。

# 2 用电信号传输TCP/IP数据
- 创建套接字
- 连接服务器
- 收发数据
- 从服务器断开连接并删除套接字
- IP与以太网的包收发操作
- 用UDP协议收发数据的操作

## 2.1 创建套接字
套接字中记录了用于控制通信操作的各种信息，协议栈则需要根据这些信息判断下一步的行动。

## 调用socket时的操作
浏览器委托协议栈使用TCP协议来收发数据。

```c
<描述符> = socket(<使用IPv4>, <使用TCP>,...);
connect(...);
write(...);
<接收数据长度> = read(...);
close(<描述符>);
```

## 2.2 连接服务器
这里的连接，指的通信双方交换控制信息。

当执行数据收发操作时，还需要一块用来临时存放要收发数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作过程中分配的。

### 负责保存控制信息的头部
通信操作中使用的控制信息分为两类：

- 头部中记录的信息
- 套接字（协议栈中的内存空间）中记录的信息

### 连接操作的实际过程
第一次握手：
- 客户端先创建一个表示开始数据收发操作的控制信息头部；
重点是发送方和接收方的端口号。
- 然后，将头部中的控制位的SYN比特设置为1，表示连接；
- 接下来，TCP模块会将信息传递给IP模块并委托它进行发送；

第二次握手：
- 服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字；
- 套接字中会写入响应的信息，并将状态改为正在连接；
- 服务器TCP模块会返回响应，这个过程与客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。此外，在返回响应时还需要将ACK控制位设为1，这表示已经接收到响应的网络包；
- 接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应；

第三次握手：
- 网络包返回客户端，通过IP模块到大TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功，这时会向套接字中写入服务器IP地址、端口号等信息，同时还会将状态改为连接完毕；
- 客户端将ACK比特设置为1并发回服务器，告诉服务器刚才的响应包已经收到；
- 服务器收到这个包之后，连接操作才算全部完成。

## 2.3 收发数据
### 将HTTP请求消息交给协议栈
- MTU：一个网络包的最大长度，以太网中一般为1500字节。
- MSS：除去头部后，一个网络包所能容纳的TCP数据的最大长度。

什么时候发送数据取决于两个条件：

- 从应用程序收到的数据长度超过MSS或接近MSS；
- 达到等待时间；

第一个是为了避免发送大量的小包，降低网络的效率；第二个是为了降低发送延迟，即使缓冲区的数据长度没有达到MSS，也应该果断发送出去。

应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。

### 对较大的数据进行拆分
发送缓冲区中的数据会被以MSS长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。

### 使用ACK号确认网络包已收到
TCP具备确认对方是否成功收到网络包，以及当对方没收到进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。

一般在发送报文中需要有两个数据：

- 数据段相对于头部的字节数；
- 数据段的长度；

服务器返回报文时，会发送ACK序号，指出想要的下一个序列。

实际发送过程中，序号是随机产生的，并且在连接过程就已经发送给服务器了。服务器收到SYN=1的报文后，同样需要返回自己的序号以及ACK。

### 根据网络包平均往返时间调整ACK号等待时间
当网络传输繁忙时就会发生拥塞，ACK号的返回会变慢，这时我们就必须等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的ACK号才姗姗来迟的情况。

### 使用窗口有效管理ACK号
为了避免一来一回造成的带宽浪费，TCP采用了滑动窗口协议。

- 滑动窗口：在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。

问题：如果不等返回ACK号就连续发送包，就有可能出现发送包的频率超过接受方处理能力的情况。

处理方法：

- 接收方需要告诉发送方自己最多能接收多少数据；
- 发送方根据这个值对数据发送操作进行控制。

### ACK与窗口的合并
接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程很有可能会出现其他的通知操作，这就可以把两种通知合并在一个包里面发送了。

当需要连续更新窗口大小或连续发送ACK时，只要发送最后结果就可以了。

### 接收HTTP响应消息
浏览器在委托协议栈发送请求消息之后，会调用read程序来获取相应消息。然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来的操作。

协议栈接收数据：

- 协议栈检查收到的数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号；
- 然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；
- 将数据交给应用程序后，协议栈还需要找到合适的时机向发送方发送窗口更新。

## 2.4 从服务器断开并删除套接字
数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。

协议栈在设计上允许任何一方先发起断开过程。

以服务器一方发起断开为例：

第一次挥手：
- 首先，服务器一方的应用程序会调用Socket库中的close程序；
- 然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是讲控制位中的FIN比特设为1；
- 接下来，协议栈会委托IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。

第二次挥手：
- 当收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态；
- 然后，为了告知服务器已收到FIN为1的包，客户端回想服务器返回一个ACK号；
  
这些操作完成后，协议栈就可以了等待应用程序来取数据了；

第三次挥手：
- 客户端应用程序调用close来结束收发操作，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器；

第四次挥手：
- 服务器返回ACK号，通信全部结束。

### 删除套接字
套接字不会立即删除，而是等待一段时间再被删除。

等待这段时间是为了防止误操作，引发误操作的原因有很多：

- 服务器没有收到最后的ACK，客户端又重新建立了一个相同端口的连接，对方重新传入FIN，这个连接就失效了；

由于重传FIN导致了新的连接失效，所以一般来说会等待几分钟之后再删除套接字。

### 数据收发操作小结

- 创建套接字；
- 客户端发起连接操作：
  - 客户端生成SYN为1的TCP包并发送给服务器，这个TCP包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要的窗口大小；
  - 服务器向客户端返回一个SYN为1的TCP包，同样包括序号和窗口大小以及表示已经收到包的ACK号；
  - 客户端收到后，发送一个确认的ACK号；
  - 连接完成；
- 双方进入数据收发阶段：
  - 客户端向服务器发送请求消息，TCP会将请求消息分成一定大小的块，并在每一块前面加上TCP头部，然后发送给服务器。TCP头部中包含序号，它表示当前发送的是第几个字节的数据。
  - 当服务器收到数据时，会向客户端返回ACK号。随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会逐步释放。这是，服务器需要将新的窗口发小告知客户端。当服务器收到客户端的请求消息后，会向客户端返回响应消息。这个过程与刚才的过程刚好相反。
  - 数据收发操作结束；
- 执行断开操作：以Web为例，服务器先发起断开。
  - 服务器先发送一个FIN为1的TCP包；
  - 客户端返回一个表示确认的ACK包；
  - 双方还会交换一组方向相反的FIN为1的TCP包和包含ACK号的TCP包。
  - 等待一段时间后，套接字会被删除。

## 2.5 IP与以太网的包收发操作

### 包
TCP/IP包包含如下两个头部：
- MAC头部
- IP头部

IP协议委托以太网协议将包传输过去。这时，IP协议会查找下一个路由器的以太网地址，并将这个地址写入MAC头部中。

在不同的路由器之间转换时，首先会把收到的MAC头部舍去，然后根据路由表找到转发端口。为了将包发到下一个路由器，我们该需要查出下一个路由器的MAC地址，并记录在MAC头部。这样，网络包就又被发往下一个节点了。

注意：当使用除了以太网之外的其他网络（无线局域网、ADSL、FTTH等）进行传输时，MAC头部也会被替换为适合所选通信规格的其他头部。

### 包收发操作概览
传递给网卡的网络包是由一连串0和1组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方。

接收的过程与发送的过程是相反的。

### 生成包含接收方IP地址的IP头部
IP地址是应用程序告诉TCP模块，TCP模块有告诉IP模块的。因此，这个地址的最初来源就是应用程序。IP不会自行判断包的目的地，而是将包发往程序指定的接收方，即使应用程序指定了错误的IP，IP模块也只能照做。当然，这个责任应该由应用程序来承担。

IP地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块都会有自己的IP地址。

通过route print可以查看路由表。

### 生成以太网用的MAC头部
- MAC地址长度：48bit
- MAC头部长度：14Byte

以太网包的内容可以是IP、ARP、IPv6等协议的包。

MAC地址是在网卡生产时写入ROM里的，只要将这个值读取出来写入MAC头部就可以了。

对于接收方的MAC地址，我们需要根据IP查询MAC地址的操作：

### 通过ARP查询目标路由器的MAC地址
通过ARP协议，可以把包发送连接在同一以太网中的所有设备。对于不是这个IP地址的设备会忽略广播，什么都不回答。

通过arp -a命令可以查看本地的ARP缓存。

注意，将MAC头部加在IP头部的前面，这个打包的工作是由IP模块负责的。

### 以太网的基本知识
以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术。

- 10BASE5（以太网原型）
- 采用中继式集线器的变体（10BASE-T）
- 采用交换式集线器的结构

### 将IP包转换成电或光信号发送出去
负责执行信号转换的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。

### 给网络包再加3个控制数据
网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送包的命令。接下来就轮到MAC模块进行工作了。

首先，MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分节符，在末尾加上用于检测错误的帧校验序列。

报头是一串像101010...这样1和0交替出现的比特序列，长度为56比特，它的作用是确定包的读取时机。

末尾的FCS用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串32比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。

### 向集线器发送网络包
发送信号的操作分为两种，一种是集线器的半双工模式，另一种是使用交换机的全双工模式。

网卡的MAC模块生成通用信号，然后由PHY（MAU）模块转换成可在网上中传输的格式，并通过网线发送出去。

根据以太网的规格，两台设备之间的网线不能超过100米。（双绞线，错误率低于万分之一）

### 接收返回包
首先PHY（MAU）模块会将信号转换成通用格式并发送给MAC模块，MAC模块再从头开始将信号转换为数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查FCS。

如果FCS校验没有问题，接下来就要看一下MAC头部中接收方MAC地址与网卡在初始化时分配给自己的MAC地址是否一致，以判断这个包是不是发给自己的。如果是，则将包放入缓冲区中。到这里，MAC模块的工作就完成了，接下来网卡会通知计算机收到了一个包。

通知的方式就是中断。

- 首先网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU；
- 当产生中断信号时，CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序；
- 然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。

网卡驱动被中断处理程序调用后，会在网卡的缓冲区取出收到的包，并通过MAC头部中的以太类型字段判断协议的类型。以太类型将包交给对应的协议栈就可以了，最后，协议栈会判断这个包交给哪个应用程序，并进行相应的处理。

### 将服务器的响应从IP传递给TCP
如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在IP头部的标志字段中进行标记，当收到分片的包时，IP模块会将其暂存在内部的内存空间中，然后等待IP头部中具有相同ID的包全部到达，这是因为同一个包的所有分片都具有相同的ID。这个过程叫作分片重组。

接下来包会被交给TCP模块。TCP模块会根据IP头部中的接收方和发送方的IP地址，以及TCP头部中的接收方和发送方端口号来查找对应的套接字。找到套接字之后，就可以了根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取。


这里TCP模块居然去看IP头部的数据，按理说是不应该的，但是现实就是这样，为了减低两种协议之间传递信息的开销而做出这种模糊的设计。将TCP和IP作为一个整体来看待，这样可以带来更大的灵活性。

## UDP协议的收发操作