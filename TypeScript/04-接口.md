# 接口

```typescript
// 普通限制
function printLabel(labelObj: { label: string }) {
  console.log(labelObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

首先解释一下 `labelObj: { label: string}` ，函数接收一个对象作为参数，把它赋值给 `labelObj` ，编译器要求这个对象必须有个 `label` 属性是String类型。

```typescript
// 同样的需求，接口限制
interface LabeledValue {
  label: string;
}

function printLabel( labelObj: LabelValue) {
  console.log(labelObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

注意到，这里我们没有像其他语言一样让函数 `printLabel` 实现这个接口。在这里，如果传入的对象可以通过验证列表，则可以通过。

注意注意的是，验证器里面的属性并没有顺序，需要验证的只有参数和类型。

## 可选属性

并不是接口的所有属性都是必需的，这时可以为它添加 `?` ，表示这个属性是可选的。

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare =  createSquare({color: "black"});
```

## 只读属性

一些属性只能在对象创建的时候更改，这时可以使用 `readonly` 修改变量：

```typescript
interface Point {
  readonly x: number;
  readonly y: number;
}
```

你可以通过字面量创建一个Point。赋值之后，x和y不能被更改。

```typescript
let p1: Point = { x: 10, y: 20};
p1.x = 5; // Error
```

你也可以通过 `ReadonlyArray<T>` 创建一个只读数组：

```typescript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // Error
ro.push(5); // Error
ro.length = 100; // Error
a = ro; // Error
```

最后一行可以看出，把ReadonlyArray赋值给普通数组也是非法的。但是你可以这样做：

```typescript
a = ro as number[];
```

**readonly vs const** 

readonly用在属性上，const用在变量上。

## 多余属性检查

如果传入的对象有属性不在接口中，就会提醒有错误存在。

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string, area: number} {
  // ...
}

// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare( {colour: "red", width: 100});
```

解决办法：

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

## 函数类型

接口可以解释对象中属性的类型，同时它也可以描述函数类型。我们把它叫做签名，它由参数和返回值组成。参数列表的每个参数都需要名字和类型。

```typescript
interface SearchFunc {
  (source: string, subSring: string): boolean;
}
```

```typescript
// 使用函数类型接口
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
	let result = source.search(subString);
	return result > -1;
}
```

使用